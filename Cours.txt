






Dans R Commander : \textit{Statistiques/Ajustement de modèles/Régression linéaire}.\newline
La droite des moindres carrés peut servir à prédire une nouvelle valeur de $Y$ : pour $X = x$, $Y$ est prédit par $\hat{y} = \hat{a}\bar{x}+\hat{b}$.\newline
Pour mesurer la qualité d'ajustement de la droite on considère les \textbf{résidus} :
$$e_{i} = y_{i} - (\hat{a}x_{i} + \hat{b})$$ 
(\textit{Il s'agit des segments rouges du graphique précédent.})\newline
Pour l'ajustement de la droite précédente, on a toujours : 
$$ \frac{1}{n} \sum_{i=1}^{n} e_{i} = 0$$
\textbf{Formule de décomposition de la variance:}
$$\sum_{i=1}^{n}(y_{i}-\bar{y})^{2} = \sum_{i=1}^{n}(\hat{y}_{i}-\bar{y})^{2} + \sum_{i=1}^{n} e_{i}^{2}$$
que l'on note généralement $\textrm{SCT} = \textrm{SCE} + \textrm{SCR}$ où \textit{SCT} : "Somme des Carrés Totaux", \textit{SCE} : "SC Expliqués" et \textit{SCR} : "SC Résiduels".\newline
On définit le coe cient de détermination : 
$$R^{2} = \frac{\textrm{SCE}}{\textrm{SCT}}$$
On a : 
\begin{itemize}
\item $0 \leq R^{2} \leq 1$ d'après la formule de décompositon de la variance
\item $R^{2} = r^{2}$ où $r$ est le coefficient de corrélation linéaire entre $X$ et $Y$.
\item L'ajustement par la droite est d'autant meilleur que $R^{2}$ est proche de 1 car dans ce cas : 
$$ \sum_{i=1}^{n} e_{i}^{2} \approx 0$$
\end{itemize}
\subsection{Aspects temporels}
\subsubsection{Représentation graphique}
De nombreuses données sont acquises à intervalles réguliers dans le temps : ce sont des \textbf{séries temporelles}.\newline
Des méthodes spécifiques permettent :
\begin{itemize}
\item de les représenter graphiquement
\item de décrire leurs tendances temporelles et leurs effets périodiques 
\item d'étudier leur dépendance temporelle
\item de les prédire
\end{itemize}
Représentation graphique :
\begin{itemize}
\item \textit{En abscisse :} le temps (secondes, jours, mois, années, etc\dots); 
\item \textit{En ordonnée :} les valeurs des observations.
\end{itemize}
\paragraph{Exemple : }
\begin{itemize}
%% Exemple 1
\item \textit{PIB des Etats-Unis}
\begin{itemize}
\item textit{En ordonnée :} Une observation par an.
\item \textit{En abscisse :} Intervalle d'observation : 1929 - 2012.
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm21.png}\end{center}\end{figure}
\end{itemize}
%% Exemple 2
\item \textit{Consommation d'électricité en Australie.}
\begin{itemize}
\item textit{En ordonnée :} Une donnée par demi-heure.
\item \textit{En abscisse :} Intervalle d'observation : 35 jours en juin-juillet 1991.
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm22.png}\end{center}\end{figure}
\end{itemize}
%% Exemple 3
\item \textit{Trafic aérien.}
\begin{itemize}
\item textit{En ordonnée :} Une donnée par mois
\item \textit{En abscisse :} Intervalle d'observation : 1949 à 1961.
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm23.png}\end{center}\end{figure}
\end{itemize}

%% Exemple 4
\item \textit{Production de bière en Australie.}
\begin{itemize}
\item textit{En ordonnée :} Une donnée par mois
\item \textit{En abscisse :} Intervalle d'observation : 1956 à 1995.
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm24.png}\end{center}\end{figure}
\end{itemize}

%% Exemple 5
\item \textit{Maximum journalier d'ozone à Rennes.}
\begin{itemize}
\item textit{En ordonnée :} Une donnée par jour
\item \textit{En abscisse :} Intervalle d'observation : de juin à septembre 2006.
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm25.png}\end{center}\end{figure}
\end{itemize}
\end{itemize}
\paragraph{Sous R}
L'étude sous R se fait par lignes de commandes.\newline
Supposons que la série temporelle est la variable var du tableau tab.
\begin{enumerate}
\item On commence par définir la série temporelle sous R :
$$x = \textrm{ts}(\textrm{tab}\$\textrm{var}, \textrm{start}=1980, \textrm{freq}=12)$$
\begin{itemize}
\item \textcolor{red}{\textbf{ts}} - ”time series”\newline
permet à R de voir la variable comme une série temporelle
\item \textcolor{red}{\textbf{start}} - Optionnel.\newline
permet de préciser la date de début de la série
\item \textcolor{red}{\textbf{freq}} - Optionnel.\newline
précise la période de la série, s'il y en a une (ici on suppose que la période vaut 12, ce qui est typique de données mensuelles). 
\end{itemize}
\item On peut alors travailler avec la série sous R, notamment la représenter avec :
$$\textrm{plot}(x)$$
\item La légende en abscisse se gère en général toute seule. On peut néanmoins imposer une datation personnelle, par exemple comme ceci :
\begin{lstlisting}[language=html]
dates=seq(as.POSIXlt("2006/6/7"),as.POSIXlt("2006/9/25"),"days")
plot(dates, x, type="l", xaxt="n",xlab='Jours')
r = as.POSIXct(round(range(dates), "days"))
axis.POSIXct(1, at=seq(r[1], r[2], by="month"), format="%b-%y")
\end{lstlisting}
\end{enumerate}

\subsubsection{Dépendance temporelle, la fonction d'autocorrélation (ACF) }
\paragraph{La dépendance temporelle}\textcolor{white}{.}\newline
Dans une série temporelle, il est courant d'observer une dépendance entre les différentes valeurs de la série, notamment entre les valeurs voisines.\newline
Cela peut se vérifier en calculant la corrélation ou en représentant le nuage de points entre les valeurs de la série et ses valeurs au pas de temps précédent.
\textit{Exemple : } Pour la série des max d'ozone, on construit la série des valeurs de la veille.
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm26.png}\end{center}\end{figure}
\begin{itemize}
\item Le nuage de points entre la série initiale et la série des valeurs de la veille est donné ci-contre.
\item La corrélation vaut $r = 0.68$.
\item La série est donc corrélée positivement à son passé immédiat.
\end{itemize}
\paragraph{Les ACF}\textcolor{white}{.}\newline
On note $x_{t}$, la valeur de la série à l'instant $t$, observée pour $t=1,\dots,n$.
\begin{itemize}
\item La \textbf{fonction d'autocovariance} est définie pour tout entier $h$ de $0$ à $n$ par :
$$\sigma(h) = \frac{1}{n-h} \sum_{t=1}^{n-h}(x_{t}-\bar{x})(x_{t+h}-\bar{x})$$
où $\bar{x}$ désigne la moyenne empirique de la série\footnote{
En mathématiques, la notion de \textbf{série} permet de généraliser la notion de \textbf{somme finie}.\newline
Étant donnée une suite de terme général $u_{n}$, étudier la série de terme général $u_{n}$, c'est étudier la suite obtenue en prenant la somme des premiers termes de la suite $(u_{n})_{n\in\mathbb{N}}$, autrement dit la suite de terme général $S_{n}$ défini par :
$$S_{n} = u_{0} + u_{1} + \dots + u_{n} = \sum_{k=0}^{n} u_{k}$$} : 
$$\bar{x} = \frac{1}{n} \sum_{t=1}^{n} x_{t}$$
\textbf{Remarque) :}
\begin{itemize}
\item la sommation s'arrête à $n - h$ car au-delà il n'y a plus de valeurs disponibles pour calculer $x_{t+h}$.
\item $\sigma(0)$ correspond à la variance de la série.
\end{itemize}
\item La \textbf{fonction d'autocorrélation} (ACF en anglais) est définie pour tout entier $h$ de $0$ à $n$ par :
$$\rho(h)=\frac{\sigma(h)}{\sigma(0)}$$
\textbf{Remarque) : } $\rho(h)$ calcule la corrélation entre les valeurs de la série et les valeurs \textit{"h plus tard"}.\newline
\\
Sous R : la fonction \textcolor{red}{acf($x$)} calcule et représente les ACF de la série $x$.\newline
\textit{Exemple :} les ACF de la série des max d'ozone.
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm27.png}\end{center}\end{figure}
Chaque baton représente $\rho(h)$ où $h=\textrm{" Lag"}$
\begin{itemize}
\item \textcolor{blue}{Lag=0} corrélation de la série avec elle-même (elle vaut toujours 1).
\item \textcolor{blue}{Lag=1} corrélation de la série avec son passé immédiat (on retrouve r = 0.68).
\item \textcolor{blue}{Lag=2} corrélation de la série avec la série des valeurs de l'avant-veille.
\item \textcolor{blue}{Lag= \dots} etc.
\end{itemize}
\textbf{Remarque : } les batons entre les pointillés peuvent être considérés négligeables.
\end{itemize}
\subsubsection{Tendance et saisonnalité}
On observe généralement dans une série temporelle :
\begin{itemize}
\item Une \textbf{tendance}, déterministe, qui représente le comportement moyen de la série au cours du temps. On la note $m_{t}$. Par exemple, pour une tendance linéaire : 
$$m_{t} = at + b$$
\item Une \textbf{saisonnalité}, déterministe, de période $T$, qui représente un comportement périodique (ou saisonnier) de la série (par exemple des pics de ventes tous les mois de décembre pour une série mensuelle). On la note $s_{t}$ et on a: $s_{t+T} = s_{t}$, pour tout $t$.\newline
La connaissance de $s_{1} ,\dots, s_{T}$ fournit le profil saisonnier.
\item un \textbf{reste aléatoire}, qui contient les variations aléatoires au cours du temps, ces dernières pouvant être liées entre elles dans le temps.
\end{itemize}

La tendance et la saisonnalité (avec sa période $T$) sont généralement visibles sur la représentation graphique de la série. On peut également détecter leur présences sur les ACF. \newline
\\
\paragraph{Exemple : série et ses ACF}
\subparagraph{PIB des USA de 1929 à 2012}
Série avec tendance croissante, non linéaire.
\begin{itemize}
\item tendance croissante visible sur la série.
\item les ACF décroissent lentement et restent non négligeables
\end{itemize}
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm28.png}\end{center}\end{figure}
\subparagraph{Températures moyennes mensuelles à Dubuque, Iowa, de 1964 à 1975}
Série avec saisonnalité de période $T = 12$.
\begin{itemize}
\item aspect saisonnier de période 12 visible sur la série.
\item les ACF ont également un comportement périodique de période 12
\end{itemize}
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm29.png}\end{center}\end{figure}
\subparagraph{Concentration de CO2 mensuelle à Hawaï de 1994 à 2004}
Série avec tendance et saisonnalité de période $T = 12$.
\begin{itemize}
\item tendance linéaire et saisonnalité de période 12 visibles sur la série.
\item les ACF ont un comportement périodique et décroissent faiblement.
\end{itemize}
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm30.png}\end{center}\end{figure}
\subparagraph{Max d'ozone journalier à Rennes l'été 2006}
Série sans tendance ni saisonnalité.
\begin{itemize}
\item aucune structure visible sur la série.
\item les ACF décroissent rapidement pour devenir négligeables.
\end{itemize}
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm31.png}\end{center}\end{figure}

\paragraph{Décomposition additive et multiplicative}
On note $x_{t}$ la valeur de la série à l'instant t, observée pour différents $t$.\newline
La plupart des séries observées peuvent se décomposer :
\begin{itemize}
\item de façon \textbf{additive} (la plus courante) : 
$$x_{t} = m_{t} + s_{t} + r_{t}$$
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm32.png}\end{center}\end{figure}
\item de façon \textbf{multiplicative} : 
$$x_{t} = m_{t} \times s_{t} \times r_{t}$$
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm33.png}\end{center}\end{figure}
\end{itemize}
\subsubsection{Estimation de la tendance}
On peut estimer la tendance $m_{t}$ de deux façons.
\begin{itemize}
\item \textbf{De façon paramétrique.}\newline
On suppose que $m_{t}$ admet une forme paramétrique spécifique, par exemple $m_{t} = at + b$ pour une tendance linéaire, et on estime les paramètres par la méthode des moindres carrés.
\item \textbf{De façon non-paramétrique.}\newline
On effectue des moyennes mobiles de la série, ce qui équivaut à la lisser : le lissage résultant estime la tendance, mais aucune formule exprimant cette tendance n'est fournie.
\end{itemize}
\paragraph{Estimation paramétrique de la tendance : } On considère la série du PIB aux USA.\newline
On décide d'estimer la tendance mt à l'aide de deux modèles paramétriques :
\begin{enumerate}
\item En supposant que $m_{t}$ est \textcolor{red}{linéaire} : $m_{t} = at + b$.\newline
On en déduit une estimation de $a$ et $b$ par les moindres carrés. La droite estimée est représentée en rouge ci-dessous.
\item En supposant que $m_{t}$ est \textcolor{forestgreen}{quadratique} : $m_{t} = at^{2} + bt + c$.
On estime de même $a$, $b$ et $c$ par les moindres carrés. La courbe estimée est représentée en vert ci-dessous.
\end{enumerate}
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm34.png}\end{center}\end{figure}
Le code R pour la tendance quadratique est donné ci-dessous.

\begin{lstlisting}[language=html]
temps=as.numeric(time(GDP))
temps2=temps^2
reg=lm(GDP ~ temps + temps2)
plot(GDP)
lines(temps,reg$fitted.values)
\end{lstlisting}

\paragraph{Estimation de la tendance par moyenne mobile}
La \textbf{moyenne mobile} de $x$ associée aux $k_{1} +k_{2} + 1$ coefficient$ a_{k_{1}},\dots,a_{k_{2}}$ est : 
$$M(t) = \sum_{i=-k_{1}}^{k_{2}}a_{i}x_{t+i}\textrm{ ,}\forall t = k_{1} + 1,\dots, n-k_{2}$$
où les poids somment à 1 :
$$\sum_{i=-k_{1}}^{k_{2}}a_{i}=1$$
Chaque valeur xt est donc remplacée par la moyenne pondérée des valeurs autour de $x_{t}$ : $k_{1}$ valeurs avant, $k_{2}$ valeurs après, soit en tout $k_{1} + k_{2} + 1$ valeurs moyennées.\newline
En pratique, $M(t)$ se calcule pour $t = k_{1} + 1$ à $n-k_{2}$ afin que toutes les valeurs à moyenner soient accessibles.
\subparagraph{Quelques moyennes mobiles standards :}
\begin{itemize}
\item  La \textbf{moyenne mobile arithmétique} d'ordre $p$ pour laquelle $k_{1} = p$, $k_{2} = 0$ et $a_{i} = \frac{1}{p+1}$ . Elle n'utilise que le passé de $x_{t}$.
$$\bar{M}_{p}(t)=\frac{1}{p+1}\sum_{i=-p}^{0}x_{t+i} = \frac{1}{p+1}\sum_{i=0}^{p}x_{t-i}\textrm{, }\forall t = p+1,\dots, n$$
Elle est utilisée en finance afin de comparer la valeur présente d'une action $x_{n}$ (à l'instant $t = n$) à sa tendance passée.
\item La \textbf{moyenne mobile centrée d'ordre $p$}, pour laquelle $k_{1} = k_{2}$ et :
\begin{itemize}
\item si $p=2k+1$, $a_{i} = \frac{1}{p}$ pour tout $i= -k,\dots,k$
$$M_{2k+1}(t) = \frac{1}{2k+1}(x_{t-k}+\dots+x_{t+k})$$
\item si $p=2k$, $a_{-k} = a_{k} = \frac{1}{2p}$ et $a_{i} = \frac{1}{p}$ pour tout $i= -(k-1),\dots,(k-1)$
$$M_{2k}(t) = \frac{1}{2k}\left(\frac{x_{t-k}}{2} + x_{t-k+1}+\dots+x_{t+k-1}+\frac{x_{t+k}}{2}\right)$$
\end{itemize}
\end{itemize}
\subparagraph{Exemple :}
\begin{itemize}
\item $M_{3}$ : Moyenne mobile centrée d'ordre 3
\item $M_{4}$ : Moyenne mobile centrée d'ordre 4
\end{itemize}
On considère le lissage par $M_{3}$ et $M_{4}$ de la série des 9 valeurs suivantes.

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
{ \textbf{$x(1)$}} & { \textbf{$x(2)$}} & { \textbf{$x(3)$}} & { \textbf{$x(4)$}} & { \textbf{$x(5)$}} & { \textbf{$x(6)$}} & { \textbf{$x(7)$}} & { \textbf{$x(8)$}} & { \textbf{$x(9)$}} \\ \hline
4                                      & 6                                      & 5                                      & 3                                      & 7                                      & 5                                      & 4                                      & 3                                      & 6                                      \\ \hline
\end{tabular}
\end{center}
On obtient :
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
{ \textbf{$M_{3}(1)$}} & { \textbf{$M_{3}(2)$}} & { \textbf{$M_{3}(3)$}} & { \textbf{$M_{3}(4)$}} & { \textbf{$M_{3}(5)$}} & { \textbf{$M_{3}(6)$}} & { \textbf{$M_{3}(7)$}} & { \textbf{$M_{3}(8)$}} & { \textbf{$M_{3}(9)$}} \\ \hline
-                                          & 5                                          & 4.67                                       & 5                                          & 5                                          & 5.33                                       & 4                                          & 4.33                                       & -                                          \\ \hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
{ \textbf{$M_{4}(1)$}} & { \textbf{$M_{4}(2)$}} & { \textbf{$M_{4}(3)$}} & { \textbf{$M_{4}(4)$}} & { \textbf{$M_{4}(5)$}} & { \textbf{$M_{4}(6)$}} & { \textbf{$M_{4}(7)$}} & { \textbf{$M_{4}(8)$}} & { \textbf{$M_{4}(9)$}} \\ \hline
- & - & 4.875 & 5.125 & 4.875 & 4.75 & 4.625 & - & - \\ \hline
\end{tabular}
\end{center}

\textbf{Exemples de calcul :}

$$M_{3}(2) = \frac{1}{3}(x(1)+x(2)+x(3)) = \frac{1}{3}(4+6+5) = 5$$
$$M_{4}(3) =  \frac{1}{4}(\frac{x(1)}{2}+x(2)+x(3)+x(4)+\frac{x(5)}{2}) = \frac{1}{4}(\frac{4}{2}+6+5+3+\frac{7}{2}) = 4.875$$

\textit{Application de $M_{p}$ aux données de production de bières en Australie.}\newline
Plus l'ordre est grand, plus le lissage est important.

\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm35.png}\end{center}\end{figure}
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm36.png}\end{center}\end{figure}

\subparagraph{Moyenne mobile en présence d'une saisonnalité}
Pour estimer la tendance en présence d'un saisonnalité de période $T$, il est conseillé d'utiliser une moyenne mobile centrée d'\textbf{ordre multiple de $T$}, pour atténuer l'effet saisonnier.\newline
\textit{Exemple : } le lissage de la série précédente (pour laquelle $T = 12$) donne pour $M_{36}$ (à gauche) et $M_{37}$ (à droite) :
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm37.png}\end{center}\end{figure}
Le lissage par $M_{37}$, bien que d'un ordre supérieur à $M_{36}$, est parasité par l'effet saisonnier initial.\newline
\\
Sous \textbf{R}, Pour appliquer la moyenne mobile centrée $M_{p}$ à la série x, on utilise la commande \textcolor{red}{filter}, en précisant les coefficients de la moyenne mobile.\newline
Plus précisément :
\begin{itemize}
\item si $p=2k+1$
$$\textrm{filter(}x, \textrm{rep(}1/(2\ast k+1), 2\ast k+1)) $$
La commande \textit{rep($a,n$)} crée un vecteur contenant $n$ fois la valeur $a$.
\item si $p = 2k$
$$\textrm{filter}(x, \textrm{c}(1/(4\ast k), \textrm{rep}(1/(2\ast k), 2\ast k-1), 1/(4\ast k)))$$
La commande \textit{c()} permet de concaténer dans un même vecteur un ensemble de valeurs, ici les $2k +1$ coefficients : $\frac{1}{4k}$ $(2k-1)$ fois, $\frac{1}{2k}$ et $\frac{1}{4k}$.
\end{itemize}
\subsubsection{Estimation de la saisonnalité}
Pour estimer la saisonnalité, on élimine au préalable la tendance de la série. On travaille donc avec la nouvelle série $\tilde{x}_{t}$ où : 
\begin{itemize}
\item $$\tilde{x}_{t} = x_{t} - \hat{m}_{t}$$
si on a supposé une décomposition additive, avec $\hat{m}_{t}$ une estimation de la tendance.
\item $$\tilde{x}_{t} = \frac{x_{t}}{\hat{m}_{t}}$$
dans le cas d'une décomposition multiplicative.
\end{itemize}
Le profil saisonnier $s_{1} ,\dots, s_{T}$ s'estime à partir de $\tilde{x}_{t}$ 
\begin{itemize}
\item de manière paramétrique :\newline
on suppose généralement que :
$$s_{t} = a + b\cos\left(\frac{2\pi t}{T}\right) + c\sin\left(\frac{2\pi t}{T}\right)$$
 et les coefficients a, b et c sont estimés par moindres carrés.
\item ou de manière non-paramétrique :\newline
Soit $k = 1,\dots, T$ et soit $n_{k}$ le nombre d'instants multiples de $k$ parmi $1, \dots , n$. On estime le profil saisonnier de la manière suivante:
$$\hat{s}_{k} = \frac{1}{n_{k}} \sum_{i=0}^{n_{k}-1} \tilde{x}_{i+kT}$$
La série complète $\hat{s}_{1},\dots,\hat{s}_{n}$ s'obtient par périodicité en répétant $\hat{s}_{1},\dots,\hat{s}_{T}$.\newline
\end{itemize}
\textit{Exemple :} 
\begin{itemize}

\item pour une série mensuelle de période $T = 12$, $\hat{s}_{1}$ correspond à la moyenne des mois de janvier, $\hat{s}_{2}$à la moyenne de mois de février, \dots.
\item Cas d'une décomposition additive
\begin{itemize}
\item La tendance de la série de production de bières a été estimée avec $M_{36}$
\item La série \textbf{moins} sa tendance est représentée à gauche.
\item Le profil saisonnier, à droite, est déduit en moyennant chaque mois.
\end{itemize}
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm38.png}\end{center}\end{figure}
Si x est la série sans tendance : 
$$\textrm{profil}=\textrm{aggregate}(x \sim \textrm{cycle}(x),\textrm{FUN}=\textrm{mean})$$

\item Cas d'une décomposition multiplicative
\begin{itemize}
\item La tendance de la série de trafic aérien a été estimée avec $M_{12}$.
\item La série \textbf{divisée} par sa tendance est représentée à gauche.
\item Le profil saisonnier, à droite, est déduit en moyennant chaque mois.
\end{itemize}
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm39.png}\end{center}\end{figure}
\end{itemize}
\subsubsection{Série ajustée, Série CVS (Corrigée des Variations Saisonnières)}
\paragraph{Décomposition totale d'une série}
En supposant que la série s'écrit $x_{t} = m_{t} + s_{t} + r_{t}$ , on peut estimer chacune des composantes :
\begin{enumerate}
\item On estime $m_{t}$ par $\hat{m}_{t}$ (de façon paramétrique ou par moyennes mobiles)
\item On estime $s_{t}$ à partir de $x_{t} - \hat{m}_{t}$, ce qui donne $\hat{s}_{t}$
\item On en déduit une estimation du reste $\hat{r}_{t} = x_{t}-\hat{m}_{t}-\hat{s}_{t}$
\end{enumerate}
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm40.png}\end{center}\end{figure}
Pour obtenir le graphe ci-contre: \textcolor{red}{plot(decompose(x))}.\newline
Pour récupérer la tendance : \textcolor{red}{decompose(x)\$trend}\newline
Pour récupérer la saisonnalité : \textcolor{red}{decompose(x)\$seasonal}\newline
Pour récupérer le reste : \textcolor{red}{decompose(x)\$random}
Pour récupérer le profil saisonnier :\textcolor{red}{decompose(x)\$figure}\newline
\textbf{Remarque} : le mˆeme type de décomposition est possible dans le cas multiplicatif avec : \textcolor{red}{plot(decompose(x,"multiplicative"))}
\paragraph{Série ajustée et série CVS}\textcolor{white}{.}\newline
La séri eajustée $\hat{m}_{t}+\hat{s}_{t}$ est un lissage de $x_{t}$ qui respecte la tendance et la saisonnalité.
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm41.png}\end{center}\end{figure}
La série CVS (corrigée des variations saisonnières) correspond à $x_{t} - \hat{s}_{t} = \hat{m}_{t} +\hat{r}_{t}$. Elle permet d'analyser les variations de la série sans ˆetre influencé par l'aspect saisonnier. On l'utilise parfois pour
réestimer $m_{t}$ de façon plus fine.

\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm42.png}\end{center}\end{figure}
\subsubsection{Pour aller plus loin : prévision et modélisation}

On suppose une décomposition additive : $x_{t} = m_{t} + s_{t} + r_{t}$  , ou` $s_{t}$ est de p ériode $T$.

\begin{itemize}
\item Une prévision de la série est possible grâce à la série ajustée $\hat{m}_{t} + \hat{s}_{t}$ , pourvu que $\hat{m}_{t}$ ait une forme paramétrique.\newline
\textit{Exemple : }  si $\hat{m}_{t} =\hat{a}t+\hat{b}$,alors la prévision de la série en $t=n+1$ est :
$$\hat{x}_{n+1} = \hat{m}_{n+1} + \hat{s}_{n+1} = \hat{a}(n+1) + \hat{b} + \hat{s}_{n+1-T}$$
ou` la dernière égalité est obtenue par périodicité de $\hat{s}_{t}$.\newline
\textit{Exemple : } série de CO2 à Hawaï. En noir : la série initiale, observée de 1994 à 2004. En rouge : la série ajustée $\hat{a}t + \hat{b} + \hat{s}_{t}$ , prolongée en 2005.
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm43.png}\end{center}\end{figure}
\item Pour améliorer la prévision, il convient d’essayer de prédire également le reste aléatoire $r_{t}$ , estimé par $\hat{r}_{t} = x_{t} - \hat{m}_{t} - \hat{s}_{t}$.\newline
\textit{Exemple : } $\hat{r}_{t}$ pour la série précédente (série noire - série rouge) et ses ACF.
\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/ccm44.png}\end{center}\end{figure}
Les ACF montre que $\hat{r}_{t}$ est corrélé avec son passé.
\begin{itemize}
\item On souhaite tirer parti de cette dépendance pour prédire $\hat{r}_{t}$ et améliorer la prévision en 2005.
\item Cela se fait en modélisant la dépendance de $\hat{r}_{t}$, par exemple à l’aide de modèles ARMA\footnote{
En statistique, les modèles ARMA (modèles autorégressifs et moyenne mobile), ou aussi modèle de Box-Jenkins, sont les principaux modèles de séries temporelles.\newline
Étant donné une série temporelle $X_{t}$, le modèle ARMA est un outil pour comprendre et prédire, éventuellement, les valeurs futures de cette série.\newline 
Le modèle est composé de deux parties : une part autorégressive (AR) et une part moyenne-mobile (MA). 
Le modèle est généralement noté ARMA($p,q$), où $p$ est l'ordre de la partie AR et $q$ l'ordre de la partie MA.\newline
\\
\textbf{définition :} un modèle autorégressif et moyenne-mobile d'ordres $(p,q)$ (abrégé en ARMA $(p,q)$ est un processus temporel discret ($X_{t}$, $t\in \mathbb{N}$) vérifiant :
$$X_t = \varepsilon_{t} +  \sum_{i=1}^{p} \varphi_{i} X_{t-i} + \sum_{i=1}^{q} \theta_{i} \varepsilon_{t-i}$$
où les paramètres $\varphi_{i}$ et $\theta_{i}$ sont constants, et les termes d'erreurs $\varepsilon_{i}$ sont indépendants du processus\footnote{Un processus aléatoire généralise la notion de variable aléatoire utilisée en statistiques élémentaires. On le définit comme une famille de variables aléatoires $X(t)$ associées à toutes les valeurs $\t\in T$. L'ensemble des observations disponibles $x(t)$ constitue une réalisation du processus.\newline
Si l'ensemble  est dénombrable on parle de processus discret ou de série temporelle, si l'ensemble est indénombrable on parle de processus continu.
}.
Un modèle autorégressif AR($p$) est un ARMA($p,0$). Un modèle moyenne mobile MA($q$) est un ARMA($0,q$).
}.
\end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




//////


 \begin{description}
 \item[mot1 :] définition1 ;
 \item[mot2 :] définition2.
 \end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Entrée et sortie}
\textbf{load() }:charge le jeu de données écrit avec  save\newline   
\textbf{data(x)  }:   charge le jeu de données spécifié\newline   
\textbf{read.table(file)}:     lit un fichier au format tabulaire et en fait un data frame; le séparateur de colonne par défaut sep="" désigne n'importe quel espacement; utilisez header=TRUE pour prendre la première ligne comme titre (header)   de colonne; utilisez as.is=TRUE pour empêcher les vecteurs de caractères d'être transformés en factors; utilisez skip=n  pour  ignorer les n  premières lignes ; consultez l'aide pour les options concernant le nommage des colonnes, le traitement des valeurs manquantes (NA), etc.\newline   
\textbf{read.csv2("filename",header=TRUE) }:    idem mais avec des options pré-définies pour lire les fichiers CSV\newline   
\textbf{read.delim("filename",header=TRUE)  }:   idem mais avec des options pré-définies pour lire les fichiers dont les  valeurs sont séparées par des tabulations\newline   
\textbf{read.fwf(file,widths,header=FALSE,sep=" ",as.is=FALSE) }:    lit un tableau dont toutes les colonnes ont la même largeur (fwf: fixed width format); widths est un vecteur d'entiers donnant la largeur des colonnes dans le fichier\newline   
\textbf{save("fichier", x,y)}:     enregistre les objets x et y dans le fichier, au format binaire XDR propre à R\newline\\   
\textbf{save.image("fichier") }:    enregistre tous les objets\newline\\   
\textbf{cat(\dots, file="", sep=" ")}:     affiche les arguments après les avoir converti en caractères; sep est le séparateur entre les arguments\newline\\   
\textbf{print(a, \dots)  }:   affiche les arguments; fonction générique (fonctionne différemment selon la classe de a)\newline\\   
\textbf{format(x,\dots)  }:   formate un objet R pour un affichage personnalisé\newline\\   
\textbf{write.table(x,file="",row.names=TRUE,col.names=TRUE, sep=" ") }:    affiche  x  après l'avoir converti en data frame; si quote  est TRUE, les colonnes  de caractères ou de factors sont entourés par des guillemets; sep  est le séparateur de colonnes. Avec file= suivi du chemin d'un fichier, écrit sur le disque dur\newline\\   
La plupart des fonctions d'entrée/sortie ont un argument file . Cela peut souvent être une chaîne de caractères nommant un fichier ou une connexion. Sous Windows, la connexion peut aussi être utilisée avec description ="clipboard" pour lire un tableau copié d'un tableur par le presse-papier          \newline\\   
\textbf{x <- read.delim("clipboard")    }: pour lire un tableau copié par le presse-papier depuis un tableur\newline\\   
\textbf{write.table(x,"clipboard",sep="\t",col.names=NA)}:     pour écrire un tableau vers le presse-papier pour un tableur\newline\\   
     
     
     
     
     
     
     
\subsection{Création de données}
\textbf{c(\dots)   }:  fonction combinant les arguments pour former un vecteur; avec recursive=TRUE va dans les listes pour combiner leurs éléments en un seul vecteur (plutôt qu'en un vecteur de listes)\newline\\  
\textbf{de:vers  }:   génère une séquence d'entiers; ?:? est prioritaire: 1:4 + 1 vaut ?2,3,4,5?\newline\\  
\textbf{seq(from,to) }:    génère une séquence;  by= spécifie l'incrément; length= spécifie la longueur\newline\\  
\textbf{seq(along=x)  }:   génère une suite 1, 2, \dots, length(x); utile pour les boucles for \newline\\  
\textbf{rep(x,times)  }:   répète times fois la valeur x; utilisez  each=n  pour répéter n fois  chaque élément de x; rep(c(1,2,3),2) vaut 1 2 3 1 2 3; rep(c(1,2,3),each=2) vaut  1 1 2 2 3 3\newline\\  
\textbf{data.frame(\dots)  }:   crée un data frame avec les  arguments (nommés ou non); e.g: data.frame(v=1:4, ch=c("a", "b", "c", "d"), lettre= "A"); les vecteurs plus courts (ici: "A") sont réutilisés (recyclés) plusieurs fois pour atteindre la longueur du vecteur le plus long ; à la différence d'une matrix, un data.frame est un tableau dont les colonnes peuvent être de types différents\newline\\  
\textbf{list(\dots) }:    crée une liste avec les  arguments (nommés ou non, qui peuvent être de longueur différente); e.g.: list(a=c(1,2),b="hi",c=3);\newline\\  
\textbf{matrix(x,nrow=,ncol=)  }:   crée une matrice (tous les éléments sont de même type); les éléments se répètent s'ils sont trop courts\newline\\  
\textbf{factor(x,levels=)  }:   transforme un vecteur x en factor (les niveaux sont indiqués par levels=)\newline\\  
\textbf{rbind(\dots)  }:   combine les arguments par ligne (row)\newline\\  
\textbf{cbind(\dots)  }:   combine les arguments par colonne\newline\\  


\subsection{Extraction de données}
\subsubsection{Indexer des listes}
\textbf{x[i]  }:   le ou les éléments i de la liste (renvoyé(s) sous forme de liste, à la différence des cas suivants; fonctionne comme pour les vecteurs)\newline\\  
\textbf{x[[n]]   }:  n ième élément de la liste\newline\\  
\textbf{x[["nom"]]   }:  l'élément nommé  "nom"\newline\\  
\textbf{x\$nom  }:   l'élément nommé  "nom"\newline\\  
\subsubsection{Indexer des vecteurs}
\textbf{x[n]   }:   n ième élément \newline\\  
\textbf{x[-n]    }:  tous sauf le n ième élément\newline\\  
\textbf{x[1:n]     }: les n premier éléments\newline\\  
\textbf{x[-(1:n)]    }:  les éléments de n+1 à la fin\newline\\  
\textbf{x[c(1,4,2)]    }:  des éléments spécifiques\newline\\  
\textbf{x["nom"]    }:  l'élément nommé  "nom" \newline\\  
\textbf{x[x > 3]    }:  tous les éléments plus grands que 3\newline\\   
\textbf{x[x > 3 \& x < 5]    }:  tous les éléments plus grands que 3 et plus petits que 5 \newline\\  
\textbf{x[x \%in\% c("a","and","the")] }:     les éléments appartenant à l'ensemble donné\newline\\  
\subsubsection{Indexer des matrices} 
\textbf{x[i,j]  }:    l'élément de la ligne i, colonne j\newline\\  
\textbf{x[i,]  }:    toute la ligne i \newline\\  
\textbf{x[,j]   }:   toute la colonne j \newline\\  
\textbf{x[,c(1,3)]  }:    les colonnes 1 et 3 \newline\\  
\textbf{x["nom",]  }:    la ligne nommée "nom" \newline\\  
\subsubsection{Indexer des data.frame} (comme pour les matrices plus ce qui suit)          
\textbf{x[["nom"]]   }:   la colonne nommée "nom"\newline\\  
\textbf{x\$nom   }:  la colonne nommée "nom" \newline\\  


\subsection{Conversion d'objets}
     \textbf{as.data.frame(x), as.numeric(x), as.logical(x),  as.character(x), \dots} :    conversion de type, e.g.: as.logical(x) convertit x en TRUE ou FALSE) ; pour la liste complète, faites methods(as)\newline\\
\subsection{Information sur les objets}
      \textbf{is.na(x), is.null(x), is.array(x), is.data.frame(x), is.numeric(x), is.complex(x), is.character(x), \dots} :     tests de type; renvoie TRUE ou FALSE; pour une liste complète, faites  methods(is)\newline\\  
      \textbf{length(x)  } :   nombre d'éléments dans x\newline\\  
     \textbf{ dim(x)    } : récupère ou définit (dim(x) <- c(3,2)) les dimensions d'un objet\newline\\  
     \textbf{ nrow(x) et NROW(x)} :     nombre de lignes; NROW(x)  considère un vecteur comme une matrice\newline\\  
      \textbf{ncol(x) et NCOL(x)   } :  idem pour les colonnes\newline\\  
      \textbf{class(x) } :    récupère ou définit la classe de x; class(x) <- "maclasse"\newline\\  
      \textbf{unclass(x)  } :   enlève l'attribut de classe de x\newline\\  
      \textbf{attr(x,which=) } :    récupère ou définit un attribut de x\newline\\  
      \textbf{attributes(x) } :    récupère ou définit la liste des attributs de x\newline\\  
      \textbf{which.max(x)  } :   trouve l'indice du plus grand élément de x\newline\\  
      \textbf{which.min(x)  } :   trouve l'indice du plus petit élément de x\newline\\  
      \textbf{rev(x)} :     renverse l'ordre des éléments de x\newline\\  
      \textbf{sort(x)  } :   trie les éléments de x par ordre croissant; pour l'ordre décroissant: rev(sort(x))\newline\\  
      \textbf{order()  } :   renvoie une série d'indices permettant de permuter un tableau afin de le mettre dans l'ordre selon les valeurs de certaines colonnes; e.g.,trier par ordre alphabétique de prénom le tableau suivant:\newline\\   \textbf{x<-data.frame(prenom=c("Bernard", "Charles", "Annie"),age=c(10,20,30)); x[order(x\$prenom),]}\newline\\  
      \textbf{cut(x,breaks)} :     découpe x en intervalles (factors); breaks est le nombre de cas ou un vecteur de cloisons\newline\\  
      \textbf{which(x == a)  } :   renvoie les indices de x pour lesquels le résultat de l'opération logique est vrai (TRUE), dans cette exemple les valeurs de i pour lesquelles  x[i]==a (l'argument de cette fonction doit être une variable de type " logique " (vrai ou faux))\newline\\  
      \textbf{na.omit(x)} :     supprime les observations avec des valeurs manquantes (NA: not available); supprime les lignes correspondantes si x est une matrice ou un data.frame)\newline\\  
      \textbf{unique(x) } :    renvoie  x sans les éléments dupliqués (pour un data.frame, ne renvoie que des lignes uniques)\newline\\  
      \textbf{table(x)} :     renvoie une table avec le décompte de chaque valeur différente de x; table(x,y) renvoie un tableau de contingence\newline\\  

\subsection{Mathématiques}
     \textbf{sin,cos,tan,log,log10,exp  } :     fonctions mathématiques\newline\\  
    \textbf{ max(x)   } :    maximum des éléments de x\newline\\  
    \textbf{ min(x)   } :    minimum des éléments de x\newline\\  
    \textbf{ range(x) } :     mini et maxi: c(min(x), max(x))\newline\\  
    \textbf{ sum(x)   } :    somme des éléments de x\newline\\  
   \textbf{  diff(x)  } :     différence entre chaque élément de x et son prédécesseur\newline\\  
   \textbf{  prod(x)  } :     produit des éléments de x\newline\\  
   \textbf{  mean(x)   } :    moyenne des éléments de x\newline\\  
    \textbf{ median(x) } :      médiane des éléments de x\newline\\  
    \textbf{ quantile(x,probs=)    } :   quantiles correspondant aux probabilités données; le paramètre par défaut\newline\\  
    \textbf{probs=c(0,.25,.5,.75,1) } :  donne les quartiles\newline\\  
  \textbf{   weighted.mean(x, w)  } :    moyenne pondérée de x (pondération par w)\newline\\  
  \textbf{   rank(x)  } :     rang des éléments de x\newline\\  
   \textbf{  var(x) ou cov(x)  } :     variance des éléments de x (calculé avec n-1 au dénominateur); si x est une matrice ou un data.frame, la matrice de  variance/covariance est calculée\newline\\  
   \textbf{  sd(x)   } :    écart-type (standard deviation) de x\newline\\  
   \textbf{  cor(x)   } :    matrice de corrélation de x (pour une matrice ou un data.frame)\newline\\  
   \textbf{  var(x, y) ou  cov(x, y)    } :   covariance entre x et y, ou entre les colonnes de x et celles de y si ce sont des matrices ou des data frames.\newline\\  
    \textbf{ cor(x, y)   } :    coefficient de corrélation linéaire  entre x et y, ou matrice de corrélation si ce sont des matrices ou des data frames.\newline\\  
   \textbf{  round(x, n)     } :  arrondit les éléments de x à n décimales\newline\\  
    \textbf{ pmin(x,y,\dots)  } :     un vecteur dont le ième élément est le minimum  des valeurs x[i], y[i], \dots\newline\\  
    \textbf{ pmax(x,y,\dots)  } :     idem pour le maximum\newline\\  
    \textbf{ union(x,y), intersect(x,y), setdiff(x,y)   } :    union et intersection d'ensembles; setdiff(x,y) trouve les éléments de x qui ne sont pas dans y\newline\\  
   \textbf{  abs(x)  } :     valeur absolue\newline\\  
  \textbf{   filter(x,filter)    } :   applique un filtre linéaire à une série temporelle; e.g., pour une moyenne mobile sur trois périodes: filter(x, c(1/3, 1/3, 1/3))\newline\\  
  \textbf{   na.rm=FALSE   } :    De nombreuses fonctions mathématiques ont un paramètre  na.rm=TRUE (non available removed) pour enlever les données manquantes (NA) avant le calcul\newline\\  



\subsection{Matrices}
   \textbf{  t(x)    } :   transposée\newline\\  
   \textbf{  diag(x)    } :   diagonale\newline\\  
    \textbf{\%*\%} :     multiplication de matrices\newline\\  
   \textbf{  solve(a,b)   } :    trouve  x tel que a \%*\% x = b\newline\\  
   \textbf{  solve(a)   } :    matrice inverse de a\newline\\  
   \textbf{  rowsum(x)   } :    somme par ligne d'une matrice ou d'un objet similaire \newline\\  
  \textbf{   colsum(x)   } :    somme par colonne\newline\\  
  \textbf{   rowMeans(x)    } :   moyenne des lignes d'une matrice\newline\\  
  \textbf{   colMeans(x)   } :    idem pour les colonnes\newline\\  



\subsection{Traitement avancé des données}
 \textbf{    apply(X,MARGIN,FUN=, \dots)    } :   applique une fonction FUN aux marges de X (MARGIN=1 pour les lignes, MARGIN=2 pour les colonnes); les paramètres \dots sont passés à la fonction FUN.\newline\\  
  \textbf{   lapply(X,FUN)   } :    applique une fonction FUN à chaque élément de X\newline\\  
   \textbf{  merge(x,y)  } :     fusionne 2 data frames en utilisant leurs noms de colonnes en commun (ou en les désignant avec by.x et by.y)\newline\\  
  \textbf{   aggregate(x,by,FUN)   } :    divise le data frame x en groupes, calcule la fonction FUN pour chacun; by est une liste d'éléments de regroupement, chaque élément aussi long que le nombre de ligne de x\newline\\  
  \textbf{   stack(x, \dots)   } :    transforme un tableau en plusieurs colonnes en tableau à 1 colonne, en indiquant d'où vient chaque valeur; e.g.: stack(data.frame(a=1:3,b=4:6))\newline\\  
  \textbf{   unstack(x, \dots)   } :   inverse de stack()\newline\\  
  \textbf{   reshape(x, \dots)   } :    fonction avancée (et compliquée) réorganisant  en largeur ou en longueur une data.frame (e.g.: un tableau de 2 variables avec 3 années pour 4 pays contient 24 données, organisées en 2x12 ou 6x4 8x3; reshape convertit entre ces formats)\newline\\  

 \subsection{Chaînes de caractères}
  \textbf{   paste(\dots)   } :    concatène des vecteurs après conversion en caractères ; sep= les sépare (par défaut: espace)\newline\\  
   \textbf{  substr(x,start,stop)    } :   extrait une sous-chaîne de caractères
  \textbf{   grep(pattern,x)   } :    renvoie les indices des éléments de x dans lesquels on trouve le patron pattern, e.g.: grep ("b", c("ab", "cd", "bz"))\newline\\  
  \textbf{   tolower(x)   } :    met en minuscules\newline\\  
  \textbf{   toupper(x)   } :    met en majuscules\newline\\  
  \textbf{   match(x,table)    } :   pour chaque élément de x, renvoie NA si l'élément n'est pas trouvé dans table, sinon renvoie la position où il se trouve dans table\newline\\  
 \textbf{    x \%in\% table  } :     pour chaque élément de x, renvoie TRUE si l'élément est trouvé dans table, sinon renvoie FALSE\newline\\  
   \textbf{  nchar(x)   } :    nombre de caractères\newline\\  
     

\subsection{Dates et heures}
La classe Date enregistre des dates. POSIXct enregistre date, heure et fuseau horaire. Les comparaisons (>, < \dots), seq()ence, et écart de temps (difftime()) sont utiles. On peut enlever ou ajouter des jours à un objet Date (+, -).           
  \textbf{   as.Date(x)  } :     convertit une chaîne de caractères en date; as.Date("2009-12-31")+1 renvoie le 1er janvier 2010.\newline\\  
   \textbf{  format(x)   } :    l'inverse; on peut choisir la représentation voulue (cf. help(strftime))\newline\\  

\subsection{Périphériques graphiques}
  \textbf{   windows()   } :    ouvre une fenêtre graphique sous Windows\newline\\  
  \textbf{   x11()  } :     idem sous GNU/linux ou MacOSX\newline\\  
 \textbf{    pdf(file), png(file), jpeg(file), bmp(file), tiff(file)    } :   se prépare à écrire les instructions graphiques qui suivront dans le fichier file, au format désigné (pdf ou png recommandés); width= et height= fixent les dimensions\newline\\  
  \textbf{   dev.off()   } :    ferme la fenêtre graphique ou le fichier graphique spécifié (par défaut: celui en cours); cf. aussi  dev.cur, dev.set\newline\\  
     
\subsection{Graphiques}
\subsubsection{Commandes principales}
   \textbf{  plot(x)   } :    graphique de x (fonction générique ayant des effets différents selon l'objet)\newline\\  
   \textbf{  plot(x, y)    } :   nuage de points\newline\\  
   \textbf{  hist(x)  } :     histogramme des fréquences de x\newline\\  
   \textbf{  barplot(x)    } :   diagramme en barres\newline\\  
   \textbf{  pie(x)    } :   diagramme circulaire (" camembert ")\newline\\  
  \textbf{   boxplot(x)    } :   diagramme en boîte [boîte à moustaches]; la boîte et son milieu montrent les 3 quartiles;\newline\\   les moustaches (whisker) un intervalle de confiance de 95\% pour la médiane (s'il y a des valeurs en dehors, elles sont affichées)\newline\\  
  \textbf{   sunflowerplot(x, y)    } :   comme plot(x,y)  mais les points qui se superposent exactement sont représentés avec des " fleurs " (un pétale par valeur répétée)\newline\\  
  \textbf{   stripchart(x, method="stack")   } :    superpose les valeurs identiques du vecteur x; e.g. stripchart(round(rnorm(30,sd=5)), method="stack")\newline\\  
  \textbf{   coplot(y?x | a)    } :   nuage des points de coordonnées x, y pour chaque valeur ou intervalle de valeur de a\newline\\  
  \textbf{   mosaicplot(table(x,y))   } :    version graphique de la table de contin­gence (les surfaces des carrés sont proportionnelles aux effectifs)\newline\\  
  \textbf{   image(table(x,y))   } :    similaire mais les effectifs influencent la couleur et non la surface\newline\\  
   \textbf{  pairs(x)   } :    tableau des nuages de points entre toutes les paires de colonnes de x\newline\\  
  \textbf{   plot.ts(x)   } :    pour une ou des série(s) temporelle(s) (classe "ts"), valeurs de x en fonction du temps\newline\\  
  \textbf{   ts.plot(x)  } :     idem mais les séries peuvent ne pas commencer ou finir en même temps\newline\\  
  \textbf{   qqnorm(x)   } :    nuage des quantiles observés contre quantiles théoriques; si  x suit une loi normale, une droite; comparer qqnorm(rnorm(100)) et   qqnorm(1:100)\newline\\  
   \textbf{  qqplot(x, y)  } :     quantiles de y en fonction des quantiles de x\newline\\  
Les paramètres suivants sont communs à de nombreuses fonctions graphiques :         
  \textbf{   add=TRUE      } :  ajoute sur le graphique précédent\newline\\  
  \textbf{   axes=FALSE   } :    ne trace pas les axes\newline\\  
  \textbf{   type="p"  } :     type de représentation des coordonnées; "p": points, "l": lignes, "b": (both) points et lignes, "o": idem mais lignes sur (over) les points, "h": bâtons, "s": escaliers (données en haut des barres\newline\\   verticales), "S": idem (données en bas des barres), "n": définit la zone de coordonnées mais ne trace rien (utiliser après les commandes graphiques de bas niveau  qui suivent)\newline\\  
  \textbf{   xlim=, ylim=  } :     limites des zones du graphique, e.g. xlim=c(1,5)\newline\\  
   \textbf{  xlab=, ylab=   } :    titre des axes (caractères)\newline\\  
  \textbf{   main=    } :   titre du graphique (caractères)\newline\\  
  \textbf{   sub=   } :    sous-titre du graphique (caractères)\newline\\  



\subsubsection{Commandes graphiques de bas niveau}
Permettent de compléter un graphique existant (éventuellement vide avec plot(\dots, type="n")          
   \textbf{  points(x, y)  } :     ajoute des points (type= peut être utilisé)\newline\\  
   \textbf{  lines(x, y)  } :     ajoute des lignes\newline\\  
   \textbf{  text(x, y, labels, \dots)  } :     ajoute du texte (labels) aux coordonnées; e.g.:  plot(x, y, type="n"); text(x, y, names)\newline\\  
   \textbf{  segments(x0, y0, x1, y1)  } :     trace des segments de (x0,y0) à (x1,y1)\newline\\  
   \textbf{  abline(a,b)   } :    trace une droite (de forme y=a+b*x)\newline\\  
   \textbf{  abline(lm.obj)   } :    trace la droite de régression du modèle linéaire lm.obj\newline\\  
 \textbf{    legend(x, y, legend)  } :     ajoute une légende au point (x,y) avec les symboles donnés par legende\newline\\  
  \textbf{   axis(side)   } :    ajoute un axe en bas (side=1), à gauche (2), en haut (3) ou à droite (4); optionnels: at= pour les coordonnées des graduation, labels= pour leur texte\newline\\  
  \textbf{   box()    } :   encadre le graphique\newline\\  
  \textbf{   rug(x)   } :    ajoute près de l'axe des abscisses une petite barre pour chaque valeur de x\newline\\  
  \textbf{   locator(n)  } :     renvoie les coordonnées des clics de la souris après n clics sur le graphique\newline\\  

\subsubsection{Paramètres graphiques}
   \textbf{  par(\dots)  } :     définit les paramètres suivants pour les graphiques à venir, e.g. par(cex=2); nombre de ces paramètres peuvent aussi être utilisés directement avec une commande graphique de haut ou bas niveau, e.g. plot(x, cex=2) ; liste complète avec help(par)\newline\\  
  \textbf{   cex  } :     taille du texte et des symboles par rapport à la valeur par défaut (character expansion)\newline\\  
   \textbf{  col   } :    couleur(s) des symboles et lignes; e.g. col="red", "blue" cf.  colors(); e.g. pour créer des vecteurs de 5 couleurs, faire suivre col= de gray(0:5/5), rainbow(5) ou terrain.colors(5)\newline\\  
  \textbf{   lty   } :    type de ligne; 1: pleine, 2: tirets, 3: pointillés, 4: tirets-points, 5: longs tirets, 6: tiret-court/tiret-long; (configurable)\newline\\  
   \textbf{  lwd   } :    largeur des lignes\newline\\  
  \textbf{   pch  } :     type de symboles pour les points (code entier de 1 à 25, ou caractère entre "")\newline\\  
  \textbf{   xaxt="n"   } :    ne trace pas l'axe des abscisses\newline\\  
  \textbf{   yaxt="n"  } :     ne trace pas l'axe des ordonnées\newline\\  
\subsubsection{Groupes de graphiques conditionnels}
Pour accéder à ces fonctions, il faut faire avant: library(lattice)\newline\\  
La formule y?x trace y en fonction de x. On peut faire un graphique y?x  par sous groupe de données en indiquant l'appartenance à tel ou tel groupe par le vecteur g1: y?x | g1; pour toutes les combinaisons des séries de groupes g1 et g2:  y?x | g1*g2          
   \textbf{  xyplot(y?x)   } :    nuages de points\newline\\  
   \textbf{  barchart(y?x)   } :    diagrammes en barre\newline\\  
   \textbf{  histogram(?x)  } :     histogrammes\newline\\  
   \textbf{  bwplot(y?x)   } :    boîtes à moustache\newline\\  
   \textbf{  stripplot(y?x)  } :     graphique à une dimension, x doit être un nombre, y peut être un facteur\newline\\  
     
     
     
     

\subsection{Modèles et analyses statistiques}
  \textbf{   lm(formula)  } :     estimation d'un modèle linéaire; formula=y~a+b estime le modèle y=ax+by+c (mettre -1 dans la formule pour enlever la constante c); summary(lm(\dots)) donne des informations utiles\newline\\  
   \textbf{  glm(formula,family=) } :      estime un modèle linéaire généralisé; e.g. family= binomial(link = "logit") pour un modèle logit (cf.  ?family)\newline\\  
Après la formule, on peut en général préciser le nom du data.frame (data=) et le sous-ensemble de données (subset= suivi d'un vecteur de valeurs logiques)          
  \textbf{   predict(fit,\dots)   } :    fait une prédiction à partir du modèle estimé fit et de nouvelles données\newline\\  
  \textbf{   coef(fit)  } :     coefficients du modèle estimé\newline\\  
  \textbf{   residuals(fit)  } :     résidus du modèle\newline\\  
  \textbf{   fitted(fit)  } :     valeurs prédites par le modèle   \newline\\   
   \textbf{  rnorm(n, mean=0, sd=1)   } :    distribution gaussienne (normale)\newline\\  
  \textbf{   rt(n, df)  } :     distribution de Student (t)\newline\\  
  \textbf{   rf(n, df1, df2)   } :    distribution de Fisher?Snedecor (F)\newline\\  
Ces fonctions de distribution peuvent être modifiées en changeant la première lettre pour avoir: r (random) pour tirer des nombres au hasard; d: densité de probabilité; p: idem cumulée; q: la valeur du quantile (avec le paramètre p:    0 <  p < 1)          

\subsection{Programmation}
Fonctions permettant d'enchaîner des opérations de manière structurée. Pour avoir de l'aide sur ces fonctions, saisir leur nom entre guillemets; e.g. help("if")      \newline\\       
  \textbf{  function( arglist ) {expr}   } :    définition de fonction; arglist est une liste d'arguments, expr est une expression exécutée; e.g.: mafonction$<-$function( a, b ) {a+2*b}; mafonction(1,2) \#renvoie 5\newline\\  
  \textbf{   return(value)  } :     mis dans expr lors d'une définition de fonction, indique que la fonction doit renvoyer ce résultat (si return est absent, la fonction renvoie la dernière valeur calculée dans expr)\newline\\  
  \textbf{   if(cond) {expr}    } :   si cond est vrai (TRUE), évaluer expr\newline\\  
  \textbf{  ==  !=  <  >  <=  >=    } :   opérateurs de comparaison, dans l'ordre: égal, différent, inférieur, supérieur, inférieur ou égal, supérieur ou égal; e.g. 1==1 vaut TRUE ou  T; 1!=1 vaut FALSE ou F; dans les opérations avec des nombres, T est converti en 1 et F en 0 (T-1==0 est vrai)\newline\\  
  \textbf{   if(cond) \{cons.expr\} else \{alt.expr\} }    si cond est vrai évaluer  cons.expr sinon  évaluer alt.expr\newline\\  
    \textbf{for(var in seq) \{expr\} } :      exécute l'expression pour chaque valeur de var prises dans une sequence\newline\\  
 \textbf{    while(cond) \{expr\}  } :     exécute l'expression tant que la condition est vraie\newline\\  
 \textbf{    repeat \{expr\}  } :     répète expr en boucle; penser à l'arrêter avec if(\dots) {break} (ou avec les touches Ctrl+C)\newline\\  
 \textbf{break } :      arrête une boucle for, while ou repeat\newline\\  
  \textbf{   next   } :    arrête l'itération en cours et reprend la boucle (dans le cas de for, avec la valeur suivante de la sequence)\newline\\  
  \textbf{   ifelse(test, yes, no)  } :     pour chaque ligne/cellule de test, renvoie la valeur yes si le test est TRUE, no s'il est FALSE, NA s'il est indéterminé\newline\\  







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 00000000001000011111000010000000000000000000000
% 00000000001000010000000010000000000000000000000
% 00000000001000010000000010000000000000000000000
% 00000000001000011111000010000000000000000000000
% 00000000000000000000000000000000000000000000000
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 00000000001000011111000010000000000000000000000
% 00000000001000010000000010000000000000000000000
% 00000000001000010000000010000000000000000000000
% 00000000001000011111000010000000000000000000000
% 000000000000000000000000000000000000000000000 00
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lstlisting}[language=html]

\end{lstlisting}


v<-seq(10,60, by=10)
w<-c(20,10,31,31,61,51)
u<-c(5,5,5,32,62,49)



##---------------------------------
##---------------------------------
##---------------------------------
\textbf{Simple List}








savehistory("Sauvegarde_historique_TP1.R")
remove()







savehistory("Sauvegarde_historique_TP1.R")

 \begin{description}
 \item[help(sujet) :] documentation sur un sujet. Flèches haut et bas pour se déplacer, touche q pour quitter ;
 \item[mot2 :] définition2.
 \end{description}



\begin{lstlisting}[language=html]

\end{lstlisting}

\begin{figure}[H]\begin{center}\includegraphics[scale=1]{ilu/g1.png}\caption{Probabilité d'obtention de face entre 0 et 6}\end{center}\end{figure}





